<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Nini Manual - Configuration Library for the .NET Framework</title>
<style>
<!--
BODY
{
	font-family:georgia,verdana,arial,helvetica;
	margin:10;
	background-color:#ffffff;
	color:#000000;
    font-size:10pt;
}
PRE
{
	background:#EEEEEE;
	margin-top:1em; margin-bottom:1em; margin-left:0px;
	padding:5pt;
	border-style: solid;
	border-width:1;
	font-size:11pt;
}
.code-keyword
{
    color: #333399;
	font-weight: bold;
}
.code-comment
{
    color: #339900;
}
-->
</style>
</head>
<body bgcolor="#FFFFFF" link=blue vlink=purple class="Normal" lang=EN-US>
<h1> Nini Manual</h1>
Nini Configuration Data Management Library (<a href="http://nini.sourceforge.net/">http://nini.sourceforge.net/</a>)
<br/>
Copyright &copy; 2004 Brent R. Matzelle
<ul>
  <li> <a href="#Introduction">I. Introduction</a> 
    <ul>
      <li><a href="#WhatIsApplicationConfigurationData">What is Application Configuration 
        Data?</a></li>
      <li><a href="#TheProblem">The Problem</a></li>
      <li><a href="#IntroducingNini">Introducing Nini</a></li>
    </ul>
  </li>
  <li><a href="#GettingStarted">II. Getting Started </a> 
    <ul>
      <li><a href="#ASimpleExample">A Simple Example</a></li>
      <li><a href="#DefaultValues">Default Values</a></li>
      <li><a href="#SettingSavingRemoving">Setting, Saving, and Removing Keys</a></li>
      <li><a href="#AddingRemovingConfigs">Adding and Removing Configs</a></li>
      <li><a href="#KeyValueReplacment">Key Value Replacement</a></li>
    </ul>
  </li>
  <li><a href="#AdvancedTopics">III. Advanced Topics </a> 
    <ul>
      <li><a href="#Merging">Merging</a></li>
      <li><a href="#ValueAliases">Value Aliases</a></li>
      <li><a href="#KeyValueLists">Key Value Lists</a></li>
    </ul>
  </li>
  <li><a href="#OtherConfigurationTypes">IV. Other Configuration Types </a> 
    <ul>
      <li><a href="#XMLConfiguration">XML Configuration</a></li>
      <li><a href="#WindowsRegistryConfiguration">Windows Registry Configuration</a></li>
      <li><a href="#.NETCOnfiguration">.NET Configuration Files</a></li>
      <li><a href="#ArgvConfiguration">Command Line (Argv) Configuration</a></li>
    </ul>
  </li>
</ul>
<a name="Introduction" />
<h2>I. Introduction</h2>
<a name="WhatIsApplicationConfigurationData" />
<h3><b>What is Application Configuration Data?</b></h3>

<p>As a developer you deal with application configuration data all of the time.  
  Common examples of this are <a href="http://webopedia.com/TERM/_/_INI_file.html">INI</a> 
  files, <a href="http://webopedia.com/TERM/X/XML.html">XML</a> files, <a
href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconconfigurationfiles.asp">.NET 
  configuration files</a> (aka “.config”), the <a href="http://www.systweak.com/winreg/winreg.htm">Windows 
  registry</a>, and command line (argv) arguments.  The advantages of configuration 
  files are that they load quickly, do not take up a lot of space, and are easy 
  to edit.  </p>

<a name="TheProblem" />
<h3>The Problem</h3> 
  Attempts to create configuration file access schemes do not satisfy the needs 
of either programmers or end-users.  To give a real life scenario I worked for 
an organization that configured their original programs using the Windows registry 
API (Application Programming Interface).  Later on they developed their own ASP 
configuration class.  At about the same time another group developed an API that 
fetched the data from a database.   Then when ASP.NET came along they started 
to use Web.config.  In a matter of several years the number of configuration data 
sources grew from one to four!  Needless to say getting configuration data often 
became a grueling task.  Here are the three major areas where configuration management 
can be improved: 
<p>

<ul>
<li><b>API<br>
  </b>Developers use a configuration file format that gets their application running 
  in the shortest time possible.   However the API for accessing this data is 
  commonly added as an afterthought resulting in an inflexible API.  In very small 
  applications this might not be a problem but as a program’s codebase grows the 
  configuration information will often find itself littered throughout the application 
  code. </p>
 </li>
<li><p><b>End Users<br>
  </b>Configuration files are usually not written with the end user in mind.  
  Often the configuration options are terse programming terms that only the bravest 
  users dare to change them.  This leads to developers having to write complicated 
  configuration file editors or worse, entirely redesigning their original APIs.  
</p>

</li>
<li>
<p>
<b>Multiple Configuration Sources</b>
<br/>
  As your software matures it is not uncommon for more application configuration 
  types to be added (such as the example I gave you earlier).  This often occurs 
  because of merging code from other projects, new improved formats, and moving 
  to different programming platforms.    This forces programmers to learn multiple 
  APIs.  The end result is code that is neither consistent nor friendly to new 
  programmers.  The old configuration files aren't replaced because programmers 
  and their managers are not comfortable with altering mature code. Users that 
  edit the files are resistant to this change because they would prefer not to 
  learn a new file format.</p>

</li>
</ul>

<a name="IntroducingNini" />
<h3>Introducing Nini</h3>
<p>Nini provides a solution that attempts to eliminate the above problems. It 
  provides a large feature set that gives you functionality that you will use 
  in every phase of your project, from concept to mature product.  This is accomplished 
  through a simple, yet flexible, API that provides an abstraction over the underlying 
  configuration sources.  It solves all of the problems that I described above.  
  We’ll see how this is done in the examples below. </p>
  
  <a name="GettingStarted" />
<h2>II. Getting Started</h2>

<a name="ASimpleExample" />
<h3>A Simple Example</h3>
<p>In order to show you how Nini solves these problems let’s go over an example.  
  First, let’s take an example configuration file.  I will choose the <a href="http://webopedia.com/TERM/X/XML.html">INI 
  format</a> for most of the examples in this manual. INI files are a tried and 
  true configuration file type used in well known open source projects such as 
  <a href="http://www.mysql.com/">MySQL</a>, <a href="http://www.php.net/">PHP</a>, 
  and <a href="http://www.samba.org/">Samba</a>. They are very simple and easy 
  to edit so they remain a very popular choice. Nini contains it's own INI parser 
  class (<a href="http://nini.sourceforge.net/Reference/html/Nini.Ini.IniDocument.html">IniDocument</a>) 
  which is written entirely in C# with no <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/sysinfo/base/getprivateprofilestring.asp">Windows 
  API</a> code so it's cross platform. Here is the text of MyApp.ini for this 
  example:</p>

<pre>
<span class="code-comment"># MyApp.ini</span>
<span class="code-keyword">[Logging]</span>
File Name = MyApp.log
MessageColumns = 5
MaxFileSize = 40000000000000
</pre>

<p>Below is an example piece of code that describes how to access the configuration 
  data from the INI file from the file above: </p>

<pre><span class="code-keyword">using</span> Nini.Config;

IConfigSource source = <span class="code-keyword">new</span> IniConfigSource (&quot;MyApp.ini&quot;);

<span class="code-keyword">string</span> fileName = config.Configs[&quot;Logging&quot;].Get (&quot;File Name&quot;);
<span class="code-keyword">int</span> columns = config.Configs[&quot;Logging&quot;].GetInt (&quot;MessageColumns&quot;);
<span class="code-keyword">long</span> fileSize = config.Configs[&quot;Logging&quot;].GetLong (&quot;MaxFileSize&quot;);
</pre>
<p>Okay, that example threw a few things at you. First, we include Nini's configuration 
  namespace to the imaginary app with <strong>using Nini.Config</strong>. Next 
  we load up the INI file with the <a href="../Reference/html/Nini.Config.IniConfigSource.html">IniConfigSource</a> 
  class. In Nini, each configuration file type has it's own &quot;Source&quot; 
  class. This class knows how to load and save the file. Each of these classes 
  implements the <a href="../Reference/html/Nini.Config.IConfigSource.html">IConfigSource</a> 
  interface so that you abstractly work with multiple configuration types more 
  easily. When a file is loaded all sections (in this case the [Logging] section) 
  are converted to the interface <a href="../Reference/html/Nini.Config.IConfig.html">IConfig</a> 
  and added to a collection on the Source class. The IConfig class provides very 
  fast access to retrieve, add, or remove configuration keys (like &quot;File 
  Name&quot; in the above INI file). The methods of the IConfig class include 
  <a href="../Reference/html/Nini.Config.IConfig.Get_overloads.html">Get</a>, 
  <a href="../Reference/html/Nini.Config.IConfig.GetString_overloads.html"> GetString</a>, 
  <a href="../Reference/html/Nini.Config.IConfig.GetInt_overloads.html">GetInt</a>, 
  <a href="../Reference/html/Nini.Config.IConfig.GetFloat_overloads.html">GetFloat</a>, 
  <a href="../Reference/html/Nini.Config.IConfig.GetDouble_overloads.html">GetDouble</a>, 
  and <a href="../Reference/html/Nini.Config.IConfig.GetLong_overloads.html">GetLong</a> 
  methods. All of the methods prefixed with &quot;Get&quot; are overloaded to 
  provide more data. The next couple sections describe how to use these overloads. 
</p>
  
  <a name="DefaultValues" />
<h3>Default Values</h3>
<p>Sometimes an option will not be present in a configuration file.  This might 
  be because it hasn’t been added to the project’s main build or because it should 
  remain secret to users.  For these cases Nini provides provides overloaded methods 
  that allow a programmer to define default values.  Here’s an example:</p>

<pre><span class="code-comment">// Sets missing to the default value, &quot;Default result&quot;.</span>
<span class="code-keyword">string</span> missing = config.Get (&quot;Missing Config&quot;, &quot;Default result&quot;);

<span class="code-comment">// Sets smallNumber to the default value, 50.</span>
<span class="code-keyword">int</span> smallNumber = config.GetInt (&quot;Not Present&quot;, 50);
</pre>

<a name="SettingSavingRemoving" />
<h3>Setting, Saving, and Removing Keys</h3>
<p>It is also possible to set and save new values into the configuration file. 
  Calling the Set method will change an existing value or if it does not exist 
  add it. Here is an example:</p>
<pre>
config.Set (&quot;File Name&quot;, &quot;MyNewFile.log&quot;);
config.Set (&quot;MessageColumns&quot;, 45);
config.Remove (&quot;File Name&quot;);

source.Save ();</pre>
<p>It is necessary to call the Save method to save a file, h0wever, you can also 
  set the AutoSave property on an IConfigSource and that will automatically save 
  the file each time the Set method is called. If you want to save a document 
  to a different path or a different object then you have additional methods:</p>
  
  
<pre><span class="code-keyword">using</span> System.IO;
StringWriter writer = <span class="code-keyword">new</span> StringWriter ();
source.Save (writer); <span class="code-comment">// Save to StringWriter (TextWriter)</span>

source.Save ("some/new/path.ini"); <span class="code-comment">// Save to new path</span>
</pre>

<a name="AddingRemovingConfigs"/>

<h3>Adding and Removing Configs</h3>

<p>On occassion you will want to add and remove IConfigs yourself. Nini has a 
  simple means to accomplish both of these actions. Here is an example where I 
  create a new config and then immediately remove it.</p>

<pre>
IConfig newConfig = source.AddConfig ("NewConfig");

source.Configs.Remove (newConfig);
</pre>

<p><a name="KeyValueReplacment"/></p>
<h3>Key Value Replacement</h3>
<p>In many cases you will find that your key values are dependent on the values 
  of other keys. For instance you have a root path configuration value and several 
  values for files that use this path like in this example:</p>
  
<pre>
<span class="code-keyword">[File Path]</span>
RootPath = C:\Program Files\My Program
Logging = MyApp.log
WebPage = index.html
</pre>

<p>Without Nini if you wanted to combine the value of &quot;RootPath&quot; with 
  &quot;Logging&quot; and &quot;WebPage&quot; then you would have to perform ugly 
  string concatenations to get &quot;C:\Program Files\My Program\index.html&quot;. 
  In Nini you do not need to do this:</p>

<pre>
<span class="code-keyword">[File Path]</span>
RootPath = C:\Program Files\My Program
Logging = <strong>${RootPath}</strong>\MyApp.log
WebPage = <strong>${RootPath}</strong>\index.html
</pre>

<p>This can save you a lot of trouble concatenating them yourself and make your 
  code a lot cleaner. If you want to grab a value from a different section you 
  can do the same above but add the section name followed by a bar (&quot;|&quot;) 
  like so: <strong>${section|key}</strong>. </p>
<p>That’s how easy it is to create your first Nini configured application.  The 
  following sections will explain some more advanced features of Nini. </p>
  
  <a name="AdvancedTopics" />
<h2>III. Advanced Topics</h2>

<a name="Merging" />
<h3>Merging</h3>

<p>Merging is a very powerful functionality that allows developers to combine 
  together the configuration data from multiple sources into a single object. 
  You can potentially combine together an infinite number of different configuration 
  types into a single IConfigSource! You could add multiple INI, XML, and Registry 
  files into the same object. Pretty cool don't you think? Here is an example 
  of how to combine an INI file with an XML file:</p>

<pre>
IConfigSource mainSource = <span class="code-keyword">new</span> IniConfigSource ("MyApp.ini");
IConfigSource xmlSource = <span class="code-keyword">new</span> XmlConfigSource ("MyApp.xml");
mainSource.Merge (xmlSource);

<span class="code-comment">// Now you can access any IConfig from mainSource and xmlSource</span>
<span class="code-keyword">string</span> xmlValue = mainSource.Configs["SomeXmlSection"].Get ("AnOption");
</pre>

<p>When the data is merged between files any IConfigs of the same name or containing 
  the same keys the file being merged in will overwrite the previous ones. This 
  is very important for those of you with clients that have different configuration 
  needs. You can create your default configuration settings in one file and have 
  a client specific file that will override the settings of the main file if needed. 
  This will save you tons of work. It did for me. </p>
<a name="ValueAliases" />
<h3>Value Aliases</h3>
<p>Many configuration files have options that are clear to programmers but very 
  confusing to non-programmers. In order to help make a configuration file easier 
  for non-programmers to understand a common practice is to make the keys and 
  values read more like common human dialog.  Lets see an example of how you might 
  return a Boolean value by using a string value that’s easier for humans to understand.  
  First, let’s start with the AliasExample INI file:</p>

<pre><span class="code-comment"># AliasExample.ini</span>
<span class="code-keyword">[Web Browser]</span>
Block Popups = ON
Check For Default Browser = Off
Error Level = warn</pre>

<p>As you can see rather than using a value like &quot;1&quot; or &quot;true&quot; 
  for the value of each key I have used &quot;On&quot; and &quot;Off&quot;, which 
  hopefully are easier for users to understand. You will also notice that the 
  case between each value is not entirely uppercase or lowercase. I did this on 
  purpose to make a point. It is difficult enough to users to remember what value 
  to place in a particular key value so to make it a bit easier on them do <strong>not</strong> 
  make them remember what case to use as well! The problem with ignoring case 
  is that your code would look pretty ugly as in the following example: </p>

<pre><span class="code-keyword">bool</span> blockPopUps = (config.Get (&quot;Block Popups&quot;).ToLower () == &quot;on&quot;);
</pre>

<p>Let's define some rules to this file to make them We want the values of the 
  <strong>BlockPopUps</strong> section to return a <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystembooleanclasstopic.asp">Boolean</a> 
  value of <strong>true</strong> when the value is set to &quot;On&quot; and a 
  value of <strong>false</strong> when the value is set to &quot;Off&quot;. Furthermore, 
  I'd like the <strong>Error Level</strong> to return the integer value of 100 
  when it is set to &quot;Warn&quot; and a value of 200 when the value is set 
  to &quot;Error&quot;. The following code shows how to add rules to the GlobalAlias 
  property of the IConfigSource that defines the rules that I just defined in 
  the previous paragraph:</p>



<pre>IConfigSource source = <span class="code-keyword">new</span> IniConfigSource (&quot;AliasExample.ini&quot;);

<span class="code-comment">// Creates two Boolean aliases.</span>
source.GlobalAlias.AddAlias (&quot;On&quot;, <span class="code-keyword">true</span>);
source.GlobalAlias.AddAlias (&quot;Off&quot;, <span class="code-keyword">false</span>);

<span class="code-comment">// Sets two integer aliases.</span>
source.GlobalAlias.AddAlias (&quot;Error Level&quot;, &quot;Warn&quot;,  100);
source.GlobalAlias.AddAlias (&quot;Error Level&quot;, &quot;Error&quot;, 200);

IConfig config = source.Configs[&quot;Web Browser&quot;];
<span class="code-keyword">bool</span> blockPopUps = config.GetBoolean (&quot;BlockPopUps&quot;);
<span class="code-keyword">int</span> errorCode = config.GetInt (&quot;Error Code&quot;, <span class="code-keyword">true</span>);
</pre>
<p>The first two calls to <a href="../Reference/html/Nini.Config.IConfig.AddAlias_overloads.html">AddAlias</a> 
  add Boolean values to the text “On” and “Off”.  The next two calls to this method 
  add alias text to the “Error Level” configuration with the text of “Warn” and 
  “Error” along with the numeric values of 100 and 200, respectively.  Next I 
  fetched the key data.  The GetInt method is overloaded so that if the parameter 
  is set to <strong>true</strong> then it loads the data as an alias rather than 
  as a literal integer value.</p>
<a name="KeyValueLists"/>

<h3>Key Value Lists</h3>

<p>Nini does not have a specialized method for returning lists of information. 
  This is because there already is way to do this using a little trick with the 
  <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemstringclasstopic.asp">String.Split</a> 
  method of the .NET Framework. Here is an INI file with a list of servers separated 
  by the vertical line ("|") delimeter: </p>
<pre>
<span class="code-keyword">[MailServers]</span>
ServerList = "http://mail.yahoo.com/|http://www.hotmail.com/|http://www.mail.com/"
</pre>

Now using the Split method we will return the list of servers as an array of strings:
  
<pre>
<span class="code-keyword">string</span>[] serverList = source.Configs["MailServers"].Get ("ServerList").Split ('|');
</pre>

You can use any number of delimeters with the Split method. Be creative.  Just pick a delimeter that you will not be using as a key value.

<p><a name="OtherConfigurationTypes" /></p>
<h2>IV. Other Configuration Types</h2>

<a name="XMLConfiguration" id="XMLConfiguration" /> 
<h3>XML Configuration</h3>
<p>Nini has it's own XML configuration file structure. It provides more flexibility 
  than does the .NET configuration file format. It's main advantages are that 
  you can have more than one XML configuration file and that the format is much 
  more concise. Here is an example of the format. You will notice that it resembles 
  an INI file quite closely. The configuration values are the same as the INI 
  in the previous examples:</p>
<pre><span class="code-comment">&lt;!-- MyApp.xml --&gt;</span>
&lt;Nini&gt;
    &lt;Section Name=&quot;Logging&quot;&gt;
        &lt;Key Name=&quot;File Name&quot; Value=&quot;MyApp.log&quot; /&gt;
        &lt;Key Name=&quot;MessageColumns&quot; Value=&quot;5&quot; /&gt;
        &lt;Key Name=&quot;MaxFileSize&quot; Value=&quot;40000000000000&quot; /&gt;
    &lt;/Section&gt;
&lt;/Nini&gt;</pre>
<p>To load the file is very simple:</p>
<pre>
<span class="code-comment">// Loads the XML file</span>
XmlConfigSource source = <span class="code-keyword">new</span> XmlConfigSource ("MyApp.xml");
<span class="code-comment">// Retrieves a value</span>
<span class="code-keyword">long</span> maxFileSize = source.Configs["Logging"].GetLong ("MaxFileSize");
</pre>

<a name="WindowsRegistryConfiguration" />
<h3> Windows Registry Configuration</h3>

If you are using one of the many Microsoft Windows operating systems then you 
can access data from the <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmicrosoftwin32registryclasstopic.asp">Windows 
Registry</a>. Here is an example key path for a registry item: 
<pre>HKEY_LOCAL_MACHINE\Sofware\MyApp\Logging
    &quot;File Name&quot;       "MyApp.log"  REG_SZ
    &quot;MessageColumns&quot;  "5"          REG_DWORD
    &quot;MaxFileSize&quot;     "40000000"   REG_DWORD</pre>
<p>To access this code the method is a bit more complex than others. You must 
  create a mapping to a registry entry. This functionality will also give you 
  the ability to merge many registry keys into a single IConfigSource. Here is 
  some example code to access it:</p>
<pre>
<span class="code-keyword">using</span> Microsoft.Win32;
RegistryConfigSource source = <span class="code-keyword">new</span> RegistryConfigSource ();
<span class="code-comment">// Loads the registry tree</span>
source.AddMapping (Registry.LocalMachine, "Software\\MyApp\\Logging");
<span class="code-comment">// Retrieves a value</span>
<span class="code-keyword">long</span> maxFileSize = source.Configs["Logging"].GetLong ("MaxFileSize");
</pre>
<p>If you'd like to recursively retrieve all data under a specified registry key 
  there is a method to accomplish this as well. If you want to get all subkeys 
  underneath a key with a flat name you can do this:</p>
  
<pre>
<span class="code-keyword">using</span> Microsoft.Win32;
<span class="code-comment">// Loads the registry tree and all nodes beneath it without </span>
RegistryConfigSource source = <span class="code-keyword">new</span> RegistryConfigSource ();
source.AddMapping (Registry.LocalMachine, "Software\\MyApp", RegistryRecurse.Flattened);

<span class="code-keyword">string</span> maxFileSize = source.Configs["MyApp"].GetString ("SomeConfig");
<span class="code-keyword">long</span> maxFileSize = source.Configs["Logging"].GetLong ("MaxFileSize");
</pre>

<a name=".NETCOnfiguration"/>

<h3>.NET Configuration Files</h3>
<p>The .NET Framework has it's own configuration file mechanism that uses a specific 
  <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconconfigurationfiles.asp">XML 
  format</a>. You may be familiar with them in ASP.NET as <strong>web.config</strong> 
  files. If you are using them with Windows Forms, console applications, or services 
  you will know them as <strong>[APP NAME].exe.config</strong> files. To support 
  users that still use this configuration file format in their applications Nini 
  has support for these files as well. </p>
  
  
<pre><span class="code-comment">&lt;!-- ExampleApp.exe.config --&gt;</span>
&lt;configuration&gt;
    &lt;configSections&gt;
        &lt;section name=&quot;Logging&quot; type=&quot;System.Configuration.NameValueSectionHandler&quot; /&gt;
    &lt;/configSections&gt;
    &lt;Logging&gt;
        &lt;add key=&quot;File Name&quot; value=&quot;MyApp.log&quot; /&gt;
        &lt;add key=&quot;MessageColumns&quot; value=&quot;5&quot; /&gt;
        &lt;add key=&quot;MaxFileSize&quot; value=&quot;40000000000000&quot; /&gt;
    &lt;/Logging&gt;
&lt;/configuration&gt;</pre>

Accessing the data is very similar to loading an INI or XML file:

<pre>
IConfigSource source = <span class="code-keyword">new</span> DotNetConfigSource ();

<span class="code-keyword">string</span> fileName = config.Configs[&quot;Logging&quot;].Get (&quot;File Name&quot;);
<span class="code-keyword">int</span> columns = config.Configs[&quot;Logging&quot;].GetInt (&quot;MessageColumns&quot;);
<span class="code-keyword">long</span> fileSize = config.Configs[&quot;Logging&quot;].GetLong (&quot;MaxFileSize&quot;);
</pre> 

<p><a name="ArgvConfiguration" /></p>
<h3>Command Line (Argv) Configuration</h3>
<p>Since the beginning of programming applications have had the capability to 
  accept command line switches. These switches are simply strings passed into 
  the application when it is first started. The Windows program Xcopy has many 
  command line <a href="http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/xcopy.mspx">switches</a> 
  and the excellent downloading application wget has it's own <a href="http://linux.about.com/library/cmd/blcmdl1_wget.htm">switches</a> 
  as well. If you want to read a little more about how command line parameters 
  work in .NET <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csref/html/vcwlkcommandlineparameterstutorial.asp">click 
  here</a>. Our first example is very similar to the others you have seen so far. 
  The difference is that the <a href="../Reference/html/Nini.Config.IConfig.AddSwitch_overloads.html">AddSwitch</a> 
  method needs to be called for each configuration key. There is a short key and 
  a long key that both can be used to fetch configuration data. There is a parameter 
  to set a description for each configuration as well, which the GetUsage method 
  uses. </p>
  
  
<pre>
<span class="code-keyword">public static int</span> Main (<span class="code-keyword">string</span>[] args)
{
   ArgvConfigSource source = <span class="code-keyword">new</span> ArgvConfigSource (args);

   source.AddSwitch ("Logging", "file-name", "f", "Logging file name");
   source.AddSwitch ("Logging", "columns", "c", "Columns of debugging information to display");
   source.AddSwitch ("Logging", "max-file-size", "m", "Maximum allowed log size");

   <span class="code-keyword">if</span> (args.Length > 0)
   {
      <span class="code-keyword">string</span> fileName = config.Configs[&quot;Logging&quot;].Get (&quot;file-name&quot;);
      <span class="code-keyword">int</span> columns = config.Configs[&quot;Logging&quot;].GetInt (&quot;columns&quot;);
      <span class="code-keyword">long</span> fileSize = config.Configs[&quot;Logging&quot;].GetLong (&quot;max-file-size&quot;);
   }
   <span class="code-keyword">else</span>
   {
      Console.WriteLine (source.GetUsage ());
   }
}
</pre> 
  
<p>That's it for this tutorial. I hope that you found it helpful! If you have 
  any questions or suggestions for improving this manual then go to the <a href="http://nini.sourceforge.net/">Nini 
  home page</a> and use the forums, bug tracker, or feature request tools to make 
  yourself heard.</p>

<hr noshade>
Copyright &copy; 2004 Brent R. Matzelle. All rights reserved. 
</body>
</html>
